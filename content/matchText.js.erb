// -*- Mode: javascript; indent-tabs-mode: nil; js-indent-level: 4 -*- 

//console.log(`QQQ: **** >> matchText.js`);
<% if ENV['TARGET'] == 'firefox' %>
browser.
<% else %>
chrome.
<% end %>
runtime.onMessage.addListener(matchText);

//alert("QQQ: hey it's a content script");

function matchText(message, sender, sendResponse) {
    try {
    // alert(`QQQ: **** >> matchText: message: ${message}`);
    //console.log(`QQQ: **** >> matchText: message:`);
        //console.table(message);
        var s = [];
        var thing = document.documentElement;
        for (var p in thing) {
            let v = thing[p];
            if (!(/^[A-Z_]+$/.test(p))) {
                s.push(p);
            }
        }
        // alert(`QQQ: things in doc: ${s.sort().join(" ")}`);
        var textContent = thing.innerHTML;
        // alert(`QQQ: **** doc len for tab ${message.tabID}: ${textContent.length} chars`);
        var pattern = message.pattern;
    var result = [matchPlainText, matchRegex, matchXPath].
        some((fn) => fn(pattern, textContent));
    message.result = result;
        // alert(`QQQ: matchText: send back message ${message}`);
        return new Promise.resolve(message)
        sendResponse(message);
    } catch(ex) {
        alert(`QQQ: matchText: ex: ${ex}`);
    }
        return true;
}

function matchPlainText(pattern, textContent) {
    var res = textContent.indexOf(pattern) >= 0;
    if (res) {
        return res;
    }
    return (textContent.toLowerCase()).indexOf(pattern.toLowerCase()) >= 0;
}

function matchRegex(pattern, textContent) {
    if (!/[\*\?\[\(\{\\]/.test(pattern)) {
        return false;
    }
    try {
        let p = new RegExp(pattern, 'i');
        let result = p.test(textContent);
        if (result) {
            return result;
        }
        let m = /^\/(.*)\/$/.exec(pattern);
        if (m) {
            p = new RegExp(m[1], 'i');
            return p.test(textContent);
        }
    } catch(ex) {}
    return false;
}

function matchXPath(pattern) {
    if (pattern.indexOf("/") == -1) {
        // Not quite right, but don't bother setting up an xpath evaluation if
        // there's no path.
        return false;
    }
    try {
        return matchXPathAux(pattern);
    } catch(ex) {
        //alert(`tabhunter: xpath search (#1): ${msg}`);
        return false;
    }
}

function matchXPathAux(pattern) {
    var contextNode = document.documentElement;
    var namespaceResolver =
        document.createNSResolver(contextNode.ownerDocument == null
                                  ? contextNode.documentElement
                                  : contextNode.ownerDocument.documentElement);
    var resultType = XPathResult.ANY_TYPE;
    var nodeSet = null;
    try {
        nodeSet = document.evaluate(pattern, contextNode, namespaceResolver,
                                    resultType, null);
        switch (nodeSet.resultType) {
        case XPathResult.NUMBER_TYPE:
            return nodeSet.numberValue();
        case XPathResult.STRING_TYPE:
            return nodeSet.stringValue();
        case XPathResult.BOOLEAN_TYPE:
            return nodeSet.booleanValue();
        case XPathResult.FIRST_ORDERED_NODE_TYPE:
        case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
        case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
            return !!nodeSet.iterateNext();
        case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
        case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
            return (nodeSet.snapshotLength > 0 && !!nodeSet.snapshotItem(0));
        default:
            throw new Error(`Unexpected xcode result type: ${nodeSet.resultType}`);
        }
    } catch(ex) {
        var msg = ex.message;
        if (ex.inner) msg += "; " + ex.inner;
        if (ex.data) msg += "; " + ex.data;
        //alert(`tabhunter: xpath search: ${msg}`);
    }
    return false;
}

console.log(`QQQ: **** << matchText.js`);
